#!/usr/bin/env bash
set -euo pipefail

# 04-test-qemu.sh: Quick headless smoke test for either ISO install or qcow2 direct-boot (UEFI when available)

ISO="artifacts/micro-linux-ubuntu-24.04.iso"
QCOW2="artifacts/micro-linux-ubuntu-24.04.qcow2"   # generated by 03b-image-qcow2.sh

# Select exactly one mode: "iso" (install from ISO) or "qcow2" (boot disk directly)
# Defaults: env TEST_ISO=1 -> iso; TEST_ISO=0 or unset -> qcow2; CLI flags override env
MODE=""

usage() {
  cat <<EOF
Usage: $0 [--iso | --qcow2]

Exactly one mode will be chosen:
  --iso    	Boot the installer ISO and install to a qcow2 target disk
  --qcow2  	Boot the generated qcow2 disk directly (default)

Env compatibility:
  TEST_ISO=1 selects --iso; TEST_ISO=0 selects --qcow2 (overridden by CLI flags)
EOF
}

# Env default
if [[ -n "${TEST_ISO:-}" ]]; then
  if [[ "$TEST_ISO" = "1" ]]; then
    MODE="iso"
  else
    MODE="qcow2"
  fi
fi

# CLI parsing with conflict detection
cli_mode=""
for arg in "$@"; do
  case "$arg" in
    --iso)
      if [[ -n "$cli_mode" && "$cli_mode" != "iso" ]]; then
        echo "Conflicting flags: --iso and --qcow2" >&2
        usage
        exit 2
      fi
      cli_mode="iso"
      ;;
    --qcow2|--disk|--qcow2-only|--no-iso)
      if [[ -n "$cli_mode" && "$cli_mode" != "qcow2" ]]; then
        echo "Conflicting flags: --iso and --qcow2" >&2
        usage
        exit 2
      fi
      cli_mode="qcow2"
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $arg" >&2
      usage
      exit 2
      ;;
  esac
done

if [[ -n "$cli_mode" ]]; then
  MODE="$cli_mode"
fi

# Final default if nothing selected
if [[ -z "$MODE" ]]; then
  MODE="qcow2"
fi

# Prefer UEFI if OVMF is available (use pflash CODE+VARS if possible)
UEFI_ARGS=()
ART_DIR="artifacts"
mkdir -p "$ART_DIR"

# NAT networking with SSH port-forward (host:2222 -> guest:22)
NIC_ARGS=( -nic user,model=virtio-net-pci,hostfwd=tcp::2222-:22 )

# Decide acceleration and CPU mode (KVM vs TCG) and handle sudo if needed
ACCEL=()
CPU_ARG="host"

setup_accel() {
  # If KVM device exists, ensure we can access it; else fall back to TCG
  if [[ -e /dev/kvm ]]; then
    if [[ -r /dev/kvm && -w /dev/kvm ]]; then
      ACCEL=( -enable-kvm )
      CPU_ARG="host"
      return 0
    fi
    # Not accessible; try escalating to sudo for KVM, else fall back to TCG
    if [[ $EUID -ne 0 ]] && command -v sudo >/dev/null 2>&1; then
      echo "Re-running with sudo for KVM access (need /dev/kvm)." >&2
      exec sudo -E bash "$0" "$@"
    else
      echo "KVM not accessible; falling back to TCG (software accel)." >&2
    fi
  fi
  # No KVM: use TCG and a generic CPU model
  ACCEL=( -accel tcg )
  CPU_ARG="max"
}

setup_accel "$@"

pick_ovmf() {
  local code_candidates=(
    "/usr/share/OVMF/OVMF_CODE_4M.fd"
    "/usr/share/OVMF/OVMF_CODE.fd"
    "/usr/share/OVMF/OVMF_CODE.secboot.fd"
  )
  local vars_candidates=(
    "/usr/share/OVMF/OVMF_VARS_4M.fd"
    "/usr/share/OVMF/OVMF_VARS.fd"
  )
  local code="" vars=""
  for c in "${code_candidates[@]}"; do [[ -f "$c" ]] && code="$c" && break; done
  for v in "${vars_candidates[@]}"; do [[ -f "$v" ]] && vars="$v" && break; done
  if [[ -n "$code" && -n "$vars" ]]; then
    local vars_copy="$ART_DIR/OVMF_VARS.fd"
    # Make a writable copy of VARS for this VM
    cp -f "$vars" "$vars_copy"
    UEFI_ARGS=(
      -drive if=pflash,format=raw,unit=0,readonly=on,file="$code"
      -drive if=pflash,format=raw,unit=1,file="$vars_copy"
    )
    return 0
  fi
  # Fallback: try legacy -bios if a code image exists
  if [[ -n "$code" ]]; then
    UEFI_ARGS=( -bios "$code" )
    return 0
  fi
  return 1
}

if ! pick_ovmf; then
  echo "NOTE: OVMF not found; using default BIOS." >&2
fi

case "$MODE" in
  iso)
    # ISO install test: use generated qcow2 name if not present; if existing qcow2 exists, avoid overwriting by using a separate target
    INSTALL_TARGET="$QCOW2"
    if [[ -f "$INSTALL_TARGET" ]]; then
      INSTALL_TARGET="artifacts/install-target.qcow2"
      echo "Generated qcow2 exists; using separate install target: $INSTALL_TARGET"
    fi
    if [[ -f "$ISO" ]]; then
      echo "Mode: ISO install → target $INSTALL_TARGET"
      # Create target disk if missing (default 24G to fit A/B layout)
      INSTALL_SIZE_GB=${INSTALL_SIZE_GB:-24}
      if [[ ! -f "$INSTALL_TARGET" ]]; then
        qemu-img create -f qcow2 "$INSTALL_TARGET" ${INSTALL_SIZE_GB}G >/dev/null
      fi
      # If an existing disk is smaller than 20G, warn loudly
      if [[ -f "$INSTALL_TARGET" ]]; then
        SIZE_BYTES=$(qemu-img info --output=json "$INSTALL_TARGET" | sed -n 's/.*\"virtual-size\": *\([0-9]*\).*/\1/p')
        if [[ -n "$SIZE_BYTES" && "$SIZE_BYTES" -lt $((20*1024*1024*1024)) ]]; then
          echo "WARNING: $INSTALL_TARGET virtual size is <20G; the A/B layout may fail under UEFI." >&2
        fi
      fi
      # Use explicit device wiring with bootindex to guide UEFI
  qemu-system-x86_64 "${ACCEL[@]}" -cpu "${CPU_ARG}" -m 1536 -machine q35 \
        "${UEFI_ARGS[@]}" \
        "${NIC_ARGS[@]}" \
        -drive if=none,media=cdrom,id=cd1,file="$ISO" \
        -device ide-cd,drive=cd1,bootindex=1 \
        -drive if=none,id=hd0,file="$INSTALL_TARGET",format=qcow2,discard=unmap \
        -device virtio-blk-pci,drive=hd0,bootindex=2 \
        -serial mon:stdio -display none -name micro-linux-iso || true
    else
      echo "ISO not found at $ISO" >&2
      exit 1
    fi
    ;;
  qcow2)
    if [[ -f "$QCOW2" ]]; then
      echo "Mode: qcow2 direct boot → $QCOW2"
  qemu-system-x86_64 "${ACCEL[@]}" -cpu "${CPU_ARG}" -m 1024 -machine q35 \
        "${UEFI_ARGS[@]}" \
        "${NIC_ARGS[@]}" \
        -drive if=none,id=hd0,file="$QCOW2",format=qcow2,discard=unmap \
        -device nvme,serial=deadbeef,drive=hd0,bootindex=1 \
        -serial mon:stdio -display none -name micro-linux-qcow2 || true
    else
      echo "QCOW2 not found at $QCOW2" >&2
      exit 1
    fi
    ;;
  *)
    echo "Unknown mode: $MODE" >&2
    usage
    exit 2
    ;;
esac

