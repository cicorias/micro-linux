#!/usr/bin/env bash
set -euo pipefail

# 04-test-qemu.sh: Quick headless smoke tests for ISO and qcow2 artifacts (UEFI when available)

ISO="artifacts/micro-linux-ubuntu-24.04.iso"
QCOW2="artifacts/micro-linux-ubuntu-24.04.qcow2"   # generated by 03b-image-qcow2.sh

# Toggle ISO testing (default: off). Enable via TEST_ISO=1 or --iso flag.
TEST_ISO=${TEST_ISO:-0}

# Minimal CLI parsing for convenience
for arg in "$@"; do
  case "$arg" in
    --iso)
      TEST_ISO=1
      ;;
    --no-iso|--qcow2-only)
      TEST_ISO=0
      ;;
  esac
done

# Prefer UEFI if OVMF is available (use pflash CODE+VARS if possible)
UEFI_ARGS=()
ART_DIR="artifacts"
mkdir -p "$ART_DIR"

# Decide acceleration and CPU mode (KVM vs TCG) and handle sudo if needed
ACCEL=()
CPU_ARG="host"

setup_accel() {
  # If KVM device exists, ensure we can access it; else fall back to TCG
  if [[ -e /dev/kvm ]]; then
    if [[ -r /dev/kvm && -w /dev/kvm ]]; then
      ACCEL=( -enable-kvm )
      CPU_ARG="host"
      return 0
    fi
    # Not accessible; try escalating to sudo for KVM, else fall back to TCG
    if [[ $EUID -ne 0 ]] && command -v sudo >/dev/null 2>&1; then
      echo "Re-running with sudo for KVM access (need /dev/kvm)." >&2
      exec sudo -E bash "$0" "$@"
    else
      echo "KVM not accessible; falling back to TCG (software accel)." >&2
    fi
  fi
  # No KVM: use TCG and a generic CPU model
  ACCEL=( -accel tcg )
  CPU_ARG="max"
}

setup_accel "$@"

pick_ovmf() {
  local code_candidates=(
    "/usr/share/OVMF/OVMF_CODE_4M.fd"
    "/usr/share/OVMF/OVMF_CODE.fd"
    "/usr/share/OVMF/OVMF_CODE.secboot.fd"
  )
  local vars_candidates=(
    "/usr/share/OVMF/OVMF_VARS_4M.fd"
    "/usr/share/OVMF/OVMF_VARS.fd"
  )
  local code="" vars=""
  for c in "${code_candidates[@]}"; do [[ -f "$c" ]] && code="$c" && break; done
  for v in "${vars_candidates[@]}"; do [[ -f "$v" ]] && vars="$v" && break; done
  if [[ -n "$code" && -n "$vars" ]]; then
    local vars_copy="$ART_DIR/OVMF_VARS.fd"
    # Make a writable copy of VARS for this VM
    cp -f "$vars" "$vars_copy"
    UEFI_ARGS=(
      -drive if=pflash,format=raw,unit=0,readonly=on,file="$code"
      -drive if=pflash,format=raw,unit=1,file="$vars_copy"
    )
    return 0
  fi
  # Fallback: try legacy -bios if a code image exists
  if [[ -n "$code" ]]; then
    UEFI_ARGS=( -bios "$code" )
    return 0
  fi
  return 1
}

if ! pick_ovmf; then
  echo "NOTE: OVMF not found; using default BIOS." >&2
fi

# ISO install test: use generated qcow2 name if not present; otherwise, avoid overwriting and use a separate target
INSTALL_TARGET="$QCOW2"
if [[ -f "$INSTALL_TARGET" ]]; then
  INSTALL_TARGET="artifacts/install-target.qcow2"
  echo "Generated qcow2 exists; using separate install target: $INSTALL_TARGET"
fi

if [[ "$TEST_ISO" = "1" ]]; then
  if [[ -f "$ISO" ]]; then
    echo "Launching QEMU with ISO (install to $INSTALL_TARGET)"
    # Create target disk if missing (8G default)
    if [[ ! -f "$INSTALL_TARGET" ]]; then
      qemu-img create -f qcow2 "$INSTALL_TARGET" 8G >/dev/null
    fi
    # Use explicit device wiring with bootindex to guide UEFI
    qemu-system-x86_64 "${ACCEL[@]}" -cpu "${CPU_ARG}" -m 1024 -machine q35 \
      "${UEFI_ARGS[@]}" \
      -drive if=none,media=cdrom,id=cd1,file="$ISO" \
      -device ide-cd,drive=cd1,bootindex=1 \
      -drive if=none,id=hd0,file="$INSTALL_TARGET",format=qcow2,discard=unmap \
      -device virtio-blk-pci,drive=hd0,bootindex=2 \
      -serial mon:stdio -display none -name micro-linux-iso || true
  else
    echo "ISO not found at $ISO" >&2
  fi
else
  echo "Skipping ISO test (enable with TEST_ISO=1 or --iso)." >&2
fi

if [[ -f "$QCOW2" ]]; then
  echo "Launching QEMU booting qcow2 directly ($QCOW2)"
  qemu-system-x86_64 "${ACCEL[@]}" -cpu "${CPU_ARG}" -m 1024 -machine q35 \
    "${UEFI_ARGS[@]}" \
  -drive if=none,id=hd0,file="$QCOW2",format=qcow2,discard=unmap \
  -device nvme,serial=deadbeef,drive=hd0,bootindex=1 \
    -serial mon:stdio -display none -name micro-linux-qcow2 || true
else
  echo "QCOW2 not found at $QCOW2" >&2



fi
